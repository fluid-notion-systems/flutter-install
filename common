#!/usr/bin/env bash

# Common functions and version management for Flutter Android/iOS Development Installation Scripts
# This file should be sourced by other installation scripts

# Get the directory where this script is located
COMMON_SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
VERSIONS_FILE="$COMMON_SCRIPT_DIR/VARS"

# Associative array to store versions
declare -A VERSIONS

# Function to load versions from VERSIONS file
load_versions() {
    if [[ ! -f "$VERSIONS_FILE" ]]; then
        echo "Error: VARS file not found at $VERSIONS_FILE" >&2
        return 1
    fi

    # Clear existing versions
    VERSIONS=()

    # Read versions from file, skipping comments and empty lines
    while IFS='=' read -r key value; do
        # Skip comments and empty lines
        [[ "$key" =~ ^[[:space:]]*# ]] && continue
        [[ -z "$key" ]] && continue

        # Remove leading/trailing whitespace
        key=$(echo "$key" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
        value=$(echo "$value" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')

        # Store in associative array
        VERSIONS["$key"]="$value"
    done < "$VERSIONS_FILE"
}

# Function to get version by key
get_version() {
    local key="$1"
    echo "${VERSIONS[$key]}"
}

# Function to set version by key (updates VERSIONS file)
set_version() {
    local key="$1"
    local value="$2"

    if [[ ! -f "$VERSIONS_FILE" ]]; then
        echo "Error: VARS file not found at $VERSIONS_FILE" >&2
        return 1
    fi

    # Update in memory
    VERSIONS["$key"]="$value"

    # Update in file
    if grep -q "^$key=" "$VERSIONS_FILE"; then
        # Key exists, update it
        sed -i "s/^$key=.*/$key=$value/" "$VERSIONS_FILE"
    else
        # Key doesn't exist, add it (before metadata section)
        sed -i "/^# Metadata/i $key=$value" "$VERSIONS_FILE"
    fi
}

# Function to list all versions
list_versions() {
    for key in "${!VERSIONS[@]}"; do
        echo "$key=${VERSIONS[$key]}"
    done | sort
}

# Function to print formatted version information
print_versions() {
    echo "Current version configuration:"
    echo "  Flutter: ${VERSIONS[FLUTTER]}"
    echo "  Android API Level: ${VERSIONS[ANDROID_API]}"
    echo "  Android Build Tools: ${VERSIONS[BUILD_TOOLS]}"
    echo "  Android Command Line Tools: ${VERSIONS[CMDLINE_TOOLS]}"
    echo "  Java: ${VERSIONS[JAVA]}"
    echo "  CocoaPods: ${VERSIONS[COCOAPODS]}"
    echo ""
    echo "Last updated: ${VERSIONS[LAST_UPDATED]}"
    echo "Updated by: ${VERSIONS[UPDATED_BY]}"
}

# Function to update metadata in VERSIONS file
update_metadata() {
    local updated_by="${1:-script}"
    local timestamp=$(date -u +"%Y-%m-%d %H:%M:%S UTC")

    set_version "LAST_UPDATED" "$timestamp"
    set_version "UPDATED_BY" "$updated_by"
}

# Load versions when this script is sourced
load_versions

# Set backwards compatibility variables if VARS loaded successfully
if [[ ${#VERSIONS[@]} -gt 0 ]]; then
    DEFAULT_FLUTTER_VERSION="${VERSIONS[FLUTTER]}"
    ANDROID_API_LEVEL="${VERSIONS[ANDROID_API]}"
    BUILD_TOOLS_VERSION="${VERSIONS[BUILD_TOOLS]}"
    CMDLINE_TOOLS_VERSION="${VERSIONS[CMDLINE_TOOLS]}"
    JAVA_VERSION="${VERSIONS[JAVA]}"
    COCOAPODS_VERSION="${VERSIONS[COCOAPODS]}"
else
    # Fallback versions if VARS file doesn't exist or failed to load
    DEFAULT_FLUTTER_VERSION="3.35.1"
    ANDROID_API_LEVEL="34"
    BUILD_TOOLS_VERSION="34.0.0"
    CMDLINE_TOOLS_VERSION="11076708"
    JAVA_VERSION="17"
    COCOAPODS_VERSION="latest"
fi

# Base URLs for downloads
FLUTTER_BASE_URL="https://storage.googleapis.com/flutter_infra_release/releases/stable"
CMDLINE_TOOLS_BASE_URL="https://dl.google.com/android/repository"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# Logging functions
log_info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

log_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

log_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

log_step() {
    echo -e "${PURPLE}[STEP]${NC} $1"
}

log_manual() {
    echo -e "${CYAN}[MANUAL ACTION REQUIRED]${NC} $1"
}

# Function to check if command exists
command_exists() {
    command -v "$1" >/dev/null 2>&1
}

# Function to detect operating system
detect_os() {
    if [[ "$OSTYPE" == "linux-gnu"* ]]; then
        echo "linux"
    elif [[ "$OSTYPE" == "darwin"* ]]; then
        echo "macos"
    elif [[ "$OSTYPE" == "msys" || "$OSTYPE" == "cygwin" ]]; then
        echo "windows"
    else
        echo "unknown"
    fi
}

# Function to detect shell and return appropriate config file
get_shell_config() {
    local os=$(detect_os)

    if [[ "$os" == "macos" ]]; then
        if [[ "$SHELL" == */zsh ]]; then
            echo "$HOME/.zshrc"
        else
            echo "$HOME/.bash_profile"
        fi
    else
        # Linux and others
        if [[ "$SHELL" == */zsh ]]; then
            echo "$HOME/.zshrc"
        else
            echo "$HOME/.bashrc"
        fi
    fi
}

# Function to add to PATH if not already present
add_to_path() {
    local new_path="$1"
    local shell_rc=$(get_shell_config)

    if [[ ! -f "$shell_rc" ]]; then
        touch "$shell_rc"
    fi

    if ! grep -q "$new_path" "$shell_rc" 2>/dev/null; then
        echo "export PATH=\"\$PATH:$new_path\"" >> "$shell_rc"
        log_success "Added $new_path to PATH in $shell_rc"
    else
        log_info "$new_path already in PATH"
    fi
}

# Function to add environment variable
add_env_var() {
    local var_name="$1"
    local var_value="$2"
    local shell_rc=$(get_shell_config)

    if [[ ! -f "$shell_rc" ]]; then
        touch "$shell_rc"
    fi

    if ! grep -q "export $var_name=" "$shell_rc" 2>/dev/null; then
        echo "export $var_name=\"$var_value\"" >> "$shell_rc"
        log_success "Added $var_name environment variable to $shell_rc"
    else
        log_info "$var_name environment variable already exists in $shell_rc"
    fi
}

# Function to source shell config
source_shell_config() {
    local shell_rc=$(get_shell_config)
    source "$shell_rc" 2>/dev/null || true
    log_info "Sourced $shell_rc"
}

# Function to check if running as root
check_not_root() {
    if [[ $EUID -eq 0 ]]; then
        log_error "This script should not be run as root for security reasons."
        exit 1
    fi
}

# Function to create directory if it doesn't exist
ensure_directory() {
    local dir="$1"
    if [[ ! -d "$dir" ]]; then
        mkdir -p "$dir"
        log_success "Created directory: $dir"
    else
        log_info "Directory already exists: $dir"
    fi
}

# Function to download file with resume capability
download_file() {
    local url="$1"
    local output="$2"
    local description="$3"

    if [[ -f "$output" ]]; then
        log_info "$description already exists, verifying..."
    else
        log_info "Downloading $description..."
    fi

    wget -c -O "$output" "$url"
    log_success "$description downloaded"
}

# Function to prompt user for yes/no confirmation
confirm() {
    local message="$1"
    local default="${2:-N}"

    if [[ "$default" == "Y" || "$default" == "y" ]]; then
        read -p "$message (Y/n): " -n 1 -r
        echo
        [[ $REPLY =~ ^[Nn]$ ]] && return 1 || return 0
    else
        read -p "$message (y/N): " -n 1 -r
        echo
        [[ $REPLY =~ ^[Yy]$ ]] && return 0 || return 1
    fi
}

# Function to print section header
print_section() {
    local title="$1"
    echo
    echo "════════════════════════════════════════════════════════════════"
    echo "  $title"
    echo "════════════════════════════════════════════════════════════════"
    echo
}

# Function to print manual actions summary
print_manual_actions() {
    local -a actions=("$@")

    if [[ ${#actions[@]} -gt 0 ]]; then
        print_section "MANUAL ACTIONS REQUIRED"
        log_warning "The following actions require manual intervention:"
        echo
        for i in "${!actions[@]}"; do
            echo -e "  ${CYAN}$((i+1)).${NC} ${actions[i]}"
        done
        echo
    fi
}

# Function to print installation summary
print_summary() {
    local base_dir="$1"
    local flutter_home="$2"
    local android_home="$3"
    local java_home="$4"

    print_section "INSTALLATION SUMMARY"
    echo "  Base Directory: $base_dir"
    echo "  Flutter SDK: $flutter_home"
    echo "  Android SDK: $android_home"
    echo "  Java: $java_home"
    echo
}

# Function to detect Mac architecture
detect_mac_arch() {
    local arch=$(uname -m)
    if [[ "$arch" == "arm64" ]]; then
        echo "apple_silicon"
    elif [[ "$arch" == "x86_64" ]]; then
        echo "intel"
    else
        echo "unknown"
    fi
}

# Function to get Java home path based on OS and architecture
get_java_home_path() {
    local os=$(detect_os)

    if [[ "$os" == "macos" ]]; then
        local arch=$(detect_mac_arch)
        if [[ "$arch" == "apple_silicon" ]]; then
            echo "/opt/homebrew/opt/openjdk@17/libexec/openjdk.jdk/Contents/Home"
        else
            echo "/usr/local/opt/openjdk@17/libexec/openjdk.jdk/Contents/Home"
        fi
    else
        echo "/usr/lib/jvm/java-17-openjdk-amd64"
    fi
}

# Function to get Flutter download URL based on OS
get_flutter_url() {
    local os=$(detect_os)
    local version="$1"

    if [[ "$os" == "macos" ]]; then
        echo "${FLUTTER_BASE_URL}/macos/flutter_macos_${version}-stable.zip"
    else
        echo "${FLUTTER_BASE_URL}/linux/flutter_linux_${version}-stable.tar.xz"
    fi
}

# Function to get Android Command Line Tools URL based on OS
get_cmdline_tools_url() {
    local os=$(detect_os)

    if [[ "$os" == "macos" ]]; then
        echo "${CMDLINE_TOOLS_BASE_URL}/commandlinetools-mac-${CMDLINE_TOOLS_VERSION}_latest.zip"
    else
        echo "${CMDLINE_TOOLS_BASE_URL}/commandlinetools-linux-${CMDLINE_TOOLS_VERSION}_latest.zip"
    fi
}

# Function to get Android SDK components list
get_android_sdk_components() {
    echo "platform-tools platforms;android-${ANDROID_API_LEVEL} build-tools;${BUILD_TOOLS_VERSION}"
}

# Function to run flutter doctor
run_flutter_doctor() {
    if command_exists flutter; then
        echo
        log_info "Running Flutter doctor to verify installation..."
        echo
        flutter doctor
    else
        log_warning "Flutter command not found in current session. Please restart your terminal and run:"
        echo "  flutter doctor"
    fi
}

# Function to export versions as environment variables (backwards compatibility)
export_versions() {
    export DEFAULT_FLUTTER_VERSION="${VERSIONS[FLUTTER]}"
    export ANDROID_API_LEVEL="${VERSIONS[ANDROID_API]}"
    export BUILD_TOOLS_VERSION="${VERSIONS[BUILD_TOOLS]}"
    export CMDLINE_TOOLS_VERSION="${VERSIONS[CMDLINE_TOOLS]}"
    export JAVA_VERSION="${VERSIONS[JAVA]}"
    export COCOAPODS_VERSION="${VERSIONS[COCOAPODS]}"
}
